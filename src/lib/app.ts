import * as vscode from 'vscode';

import {
	ICfg,
	IChangeData,
	IChangeTracker,
	IDictionary,
	IEditorService,
	IFileStorage,
	IScanResultData,
	ISidenote,
	IStorageService,
} from './types';

import {
	TyporaEditor,
	VscodeEditor,
} from './editorService';

import {
	ChokidarChangeTracker,
	FsWatchChangeTracker,
	VscodeChangeTracker,
} from './changeTracker';

import {
	Inspector,
	SidenoteBuilder,
	SidenoteFactory,
} from './sidenote';

import {
	MarkerUtils,
	ActiveEditorUtils,
} from './utils';

import Anchorer from './anchorer';
import Commands from './commands';
import Designer from './designer';
import Pool from './pool';
import Pruner from './pruner';
import Scanner from './scanner';
import SidenoteProcessor from './sidenoteProcessor';
import Styler from './styler';
import UuidMaker from './idMaker';
import { EventEmitter } from 'events';//TODO: use vScode eventemitter?
import { FileStorage } from './storageService';
import { MapDictionary } from './dictionary';

// TODO JSDoc
// TODO unit tests
export default class App {
	private activeEditorUtils: ActiveEditorUtils
	private changeTracker: IChangeTracker
	private commands: Commands
	private editorService: IEditorService
	private eventEmitter: EventEmitter
	private pool: Pool<ISidenote>
	private sidenoteProcessor: SidenoteProcessor
	private styler: Styler<ISidenote>

	constructor(
		private cfg: ICfg,
		private context: vscode.ExtensionContext
	) {
		this.init();
	}

	async init() {
		await this.wire();
		this.checkRequirements();
		this.registerCommands();
		this.setEventListeners();
	}

	async wire() {
		const uuidMaker = new UuidMaker;
		const eventEmitter = new EventEmitter;
		// const pool = new MapDictionary<ISidenote>();
		const pool = new Pool<ISidenote>(MapDictionary);

		const activeEditorUtils = new ActiveEditorUtils(this.cfg);
		const markerUtils = new MarkerUtils(uuidMaker, this.cfg);
		const scanner = new Scanner(markerUtils, activeEditorUtils);

		const changeTracker = new VscodeChangeTracker(uuidMaker, eventEmitter, this.context);
		// const changeTracker = new ChokidarChangeTracker(uuidMaker, eventEmitter, this.cfg, this.context);
		// const fsWatchChangeTracker: FsWatchChangeTracker = new FsWatchChangeTracker(uuidMaker, eventEmitter, this.cfg, this.context);
		// const editorService = new TyporaEditor(fsWatchChangeTracker, activeEditorUtils);
		const editorService = new VscodeEditor(changeTracker);
		// const editorService = new TyporaEditor(chokidarChangeTracker, activeEditorUtils);

		const storageService = new FileStorage(editorService, activeEditorUtils, this.cfg);
		const anchorer = new Anchorer(markerUtils, activeEditorUtils, scanner, this.cfg);
		const inspector = new Inspector;
		const designer = new Designer(markerUtils, inspector, activeEditorUtils, scanner, this.cfg);
		const sidenoteFactory = new SidenoteFactory(uuidMaker, anchorer, storageService, designer, activeEditorUtils, SidenoteBuilder);
		const sidenoteProcessor = new SidenoteProcessor(storageService, anchorer, sidenoteFactory, pool, designer);
		const styler = new Styler<ISidenote>(pool, this.cfg);
		const pruner = new Pruner(pool, sidenoteProcessor, inspector);
		const commands = new Commands(styler, pruner, sidenoteProcessor, scanner, pool, inspector);

		this.styler = styler;
		this.sidenoteProcessor = sidenoteProcessor;
		this.eventEmitter = eventEmitter;
		this.commands = commands;
		this.pool = pool;
		this.activeEditorUtils = activeEditorUtils;
		this.changeTracker = changeTracker;
		this.editorService = editorService;
	}

	checkRequirements() {
		if (this.sidenoteProcessor.storageService.checkRequirements) this.sidenoteProcessor.storageService.checkRequirements();

		if (!vscode.window.activeTextEditor) {
			throw new Error('active text editor is undefined');
		}
	}

	setEventListeners() {
		this.eventEmitter.on('sidenoteDocumentChange', async (changeData: IChangeData) => {
			// event is generated by editorService after onDidSaveDocument
			const sidenote = await this.sidenoteProcessor.get({ id: changeData.id });
			this.sidenoteProcessor.update(sidenote);
			this.styler.updateDecorations();
			// действия update и update decorations должны выполяться последовательно, т.е. должны быть в одной функции
			// требуется обращение к styler, поэтому не можем разместить ниже styler,
			// или в самом styler, т.к. styler у нас generic, а тут одно действий происходит над конкретным типом
			// надо либо весь styler переписать на ISidenote,
			// либо присвоить sidenote конкретный тип ISidenote перед выполнением update (вряд ли получится)
			// const sidenote = this.pool.get(id) as unknown as ISidenote;
		});

		const updateOnEditorChange = (editor: vscode.TextEditor) => {
			// run updates in order
			this.activeEditorUtils.onDidChangeActiveTextEditor(editor);
			this.pool.onDidChangeActiveTextEditor(editor);
			this.commands.scanDocumentAnchors();
		}

		const onDidChangeActiveEditorHandler = this.editorService instanceof VscodeEditor ?
			(editor: vscode.TextEditor) => {
				// add additional check to prevent triggering scan on sidenote files
				if(this.changeTracker.getIdFromFileName(editor.document.fileName)) return;
				updateOnEditorChange(editor);
			} :
			(editor: vscode.TextEditor) => updateOnEditorChange(editor);

		vscode.window.onDidChangeActiveTextEditor(onDidChangeActiveEditorHandler, this, this.context.subscriptions);
	}

	registerCommands() {
		return this.context.subscriptions.push(
			vscode.commands.registerCommand('sidenotes.annotate', this.commands.run, this.commands),
			vscode.commands.registerCommand('sidenotes.display', this.commands.scanDocumentAnchors, this.commands),
			vscode.commands.registerCommand('sidenotes.delete', this.commands.delete, this.commands),
			vscode.commands.registerCommand('sidenotes.pruneBroken', this.commands.prune.bind(this.commands, 'broken')),
			vscode.commands.registerCommand('sidenotes.pruneEmpty', this.commands.prune.bind(this.commands, 'empty')),
			vscode.commands.registerCommand('sidenotes.reset', this.commands.reset, this.commands),
			vscode.commands.registerCommand('sidenotes.internalize', this.commands.internalize, this.commands),
			vscode.commands.registerCommand('sidenotes.migrate', this.commands.migrate, this.commands),
			vscode.commands.registerCommand('sidenotes.extraneous', this.commands.cleanExtraneous, this.commands)
		)
	}
}
