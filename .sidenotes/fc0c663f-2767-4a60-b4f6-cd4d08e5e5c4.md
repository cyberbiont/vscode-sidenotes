гениальное решение с прокси для класса Actual:

нам нужно, чтобы все приложение использовало какой-то один объект (инстанс класса)
для этого этот инстанс генерируется в composition root и раздается по всем модулям.
Но, что если нужно его заменить? если будем передавать его в виде переменной, мы не сможем ее значением управлять после того как передали ее. Нам нужен объект, т.к. они передаются по ссылке;
нам нужно поместить значение внутрь объекта в виде св-ва и передавать ссылку на объект;
если изменим значение св-ва в этом объекте (этим должен управлять специальный класс-контроллер), изменения будут получать все, кто пользуется этим объектом.
Но, в модулях неудобно будет обращаться к этому св-ву через точку.
А копирование св-ва в переменную будет означать, что его значение будет "зафиксировано", т.е. этот способ не подходит.

Поэтому возвращаем прокси через метод гет и передаем его во все модули; а сам инатсна класса actual передаем в контооллер, который удет управлять сменой таргета для этого прокси

```js
class Actual<T extends object> {
	// т.к. Reflect.get требует первым аругементом объект, приходится тут экстендить объект
	item: T;
	constructor(initialItem: T) {
		this.actual = initialItem;
	}

	setActual(item: T): void {
		return this.actual = item;
	}

	get(): T {
		return new Proxy(this, {
			get(target, prop) {
				return Reflect.get(target.actual, prop);
			}
		});
	}
}
const actual = new Actual({
	log() { console.log('initial'); }
});

const reassignedActual = actual.actual
const proxy = actual.get();

actual.actual.log(); // initial
reassignedActual.log(); .// initial
proxy.log(); // initial

actual.setActual({
	log() { console.log('new'); }
})

actual.actual.log(); //new , работает, но обращение через точку - не найс
reassignedActual.log(); // initial, вот поэтому нельзя копировать в переменную
proxy.log(); //new

```

наверно придется тайп-кастинг использовать, т.к. TS не может инферрить тип для прокси:
https://github.com/Microsoft/TypeScript/issues/20846
